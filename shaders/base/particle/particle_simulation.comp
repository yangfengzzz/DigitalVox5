// ============================================================================

/* Second Stage of the particle system :
 * - Calculate forces (eg. curl noise, vector field, ..),
 * - Performs time integration,
 * - Handle collision detection,
 * - Update particle position and velocity,
 */

// ============================================================================

#version 450

#include "base/particle/particle_curl_noise.comp"
#include "base/particle/particle_config.h"

// ----------------------------------------------------------------------------

layout(set = 0, binding = 5) uniform particleSimulationData {
    float time_step;
    uint bounding_volume_type;
    float bbox_size;
    float scattering_factor;
    float vector_field_factor;
    float curl_noise_factor;
    float curl_noise_scale;
    float velocity_factor;
} particle_simulation_data;

// Vector field sampler.
layout(set = 0, binding = 5) uniform sampler3D uVectorFieldSampler;

// ----------------------------------------------------------------------------

layout(binding = 2) buffer readCount {
    int value;
} read_count;

layout(binding = 2) buffer writeCount {
    uint value;
} write_count;

// ----------------------------------------------------------------------------

// READ
layout(binding = 2) readonly buffer ParticleBufferA {
    TParticle value[];
} particle_buffer_a;

// WRITE
layout(binding = 2) writeonly buffer ParticleBufferB {
    TParticle value[];
} particle_buffer_b;

layout(binding = 2) readonly buffer RandomBuffer {
    float value[];
} random_buffer;

// ----------------------------------------------------------------------------

TParticle PopParticle() {
    const uint index = gl_GlobalInvocationID.x;
    atomicAdd(read_count.value, -1);
    return read_particles[index];
}

void PushParticle(in TParticle p) {
    const uint index = atomicAdd(write_count.value, 1);
    write_particles[index] = p;
}

// ----------------------------------------------------------------------------

float GetUpdatedAge(in const TParticle p) {
    return clamp(p.age - particle_simulation_data.time_step, 0.0f, p.start_age);
}

// ----------------------------------------------------------------------------

void UpdateParticle(inout TParticle p, in vec3 pos, in vec3 vel, in float age) {
    p.position.xyz = pos;
    p.velocity.xyz = vel;
    p.age = age;
}

// ----------------------------------------------------------------------------

vec3 CalculateScattering() {
    #ifdef NEED_PARTICLE_SCATTERING
        const uint gid = gl_GlobalInvocationID.x;
        vec3 randforce = vec3(randbuffer[gid], randbuffer[gid+1u], randbuffer[gid+2u]);
        randforce = 2.0f * randforce - 1.0f;
        return particle_simulation_data.scattering_factor * randforce;
    #endif

    return vec3(0.0f);
}

// ----------------------------------------------------------------------------

vec3 CalculateRepulsion(in const TParticle p) {
    vec3 push = vec3(0.0f);

    /*
    // IDEA
    const vec3 vel = p.velocity.xyz;
    const vec3 pos = p.position.xyz;
    const float MAX_INFLUENCE_DISTANCE = 8.0f;

    vec3 n;
    float d = compute_gradient(pos, n);
    float coeff = smoothstep(0.0f, MAX_INFLUENCE_DISTANCE, abs(d));
    push = coeff * (n);
    //vec3 side = cross(cross(n, normalize(vel + vec3(1e-5))), n);
    //push = mix(push, side, coeff*coeff);
    */

    return push;
}

// ----------------------------------------------------------------------------

vec3 CalculateTargetMesh(in const TParticle p) {
    vec3 pull = vec3(0.0f);

    /*
    // IDEA
    vec3 anchor = anchors_buffer[p.anchor_id];
    mat4x4 anchorModel = achor_models_buffer[p.anchor_id];
    vec3 target = anchorModel * vec4(anchor, 1.0f);
    vec3 pull = target - p.position;
    float length_pull = length(pull);
    pull *= inversesqrt(length_pull));
    float factor = MAX_PULL_FACTOR * smoothstep(0.0f, MAX_PULL_FACTOR, length_pull);
    pull *= factor;
    */

    return pull;
}

// ----------------------------------------------------------------------------

vec3 CalculateVectorField(in const TParticle p) {
    #ifdef NEED_PARTICLE_VECTOR_FIELD
        const vec3 extent = 0.5f * vec3(textureSize(uVectorFieldSampler, 0).xyz);
        const vec3 texcoord = (p.position.xyz + extent) / (2.0f * extent);
        vec3 vfield = texture(uVectorFieldSampler, texcoord).xyz;
        return particle_simulation_data.vector_field_factor * vfield;
    #endif

    return vec3(0.0f);
}

// ----------------------------------------------------------------------------

vec3 CalculateCurlNoise(in const TParticle p) {
    #ifdef NEED_PARTICLE_CURL_NOISE
        vec3 curl_velocity = compute_curl(p.position.xyz * particle_simulation_data.curl_noise_scale);
        return particle_simulation_data.curl_noise_factor * curl_velocity;
    #endif

    return vec3(0.0f);
}


// ----------------------------------------------------------------------------

vec3 CalculateForces(in const TParticle p) {
    vec3 force = vec3(0.0f);

    force += CalculateScattering();
    force += CalculateRepulsion(p);
    force += CalculateTargetMesh(p);
    force += CalculateVectorField(p);
    force += CalculateCurlNoise(p);

    return force;
}

// ----------------------------------------------------------------------------

void CollideSphere(float r, in vec3 center, inout vec3 pos, inout vec3 vel) {
    const vec3 p = pos - center;
    const float dp = dot(p, p);
    const float r2 = r*r;

    if (dp > r2) {
        vec3 n = -p * inversesqrt(dp);
        vel = reflect(vel, n);

        pos = center - r*n;
    }
}

void CollideBox(in vec3 corner, in vec3 center, inout vec3 pos, inout vec3 vel) {
    vec3 p = pos - center;

    if (p.x < -corner.x) {
        p.x = -corner.x;
        vel = reflect(vel, vec3(1.0f, 0.0f, 0.0f));
    }

    if (p.x > corner.x) {
        p.x = corner.x;
        vel = reflect(vel, vec3(-1.0f, 0.0f, 0.0f));
    }

    if (p.y < -corner.y) {
        p.y = -corner.y;
        vel = reflect(vel, vec3(0.0f, 1.0f, 0.0f));
    }

    if (p.y > corner.y) {
        p.y = corner.y;
        vel = reflect(vel, vec3(0.0f, -1.0f, 0.0f));
    }

    if (p.z < -corner.z) {
        p.z = -corner.z;
        vel = reflect(vel, vec3(0.0f, 0.0f, 1.0f));
    }

    if (p.z > corner.z) {
        p.z = corner.z;
        vel = reflect(vel, vec3(0.0f, 0.0f, -1.0f));
    }

    pos = p + center;
}

void CollisionHandling(inout vec3 pos, inout vec3 vel) {
    const float r = 0.5f * uBBoxSize;

    if (particle_simulation_data.bounding_volume == 0)
    CollideSphere(r, vec3(0.0f), pos, vel);
    else
    if (particle_simulation_data.bounding_volume == 1)
    CollideBox(vec3(r), vec3(0.0f), pos, vel);
}

// ----------------------------------------------------------------------------

layout(local_size_x = PARTICLES_KERNEL_GROUP_WIDTH) in;
void main() {
    // Local copy of the particle.
    TParticle p = PopParticle();

    float age = GetUpdatedAge(p);

    if (age > 0.0f) {
        // Calculate external forces.
        vec3 force = CalculateForces(p);

        // Integrations vectors.
        const vec3 dt = vec3(particle_simulation_data.time_step);
        vec3 velocity = p.velocity.xyz;
        vec3 position = p.position.xyz;

        // Integrate velocity.
        velocity = fma(force, dt, velocity);

        #ifdef NEED_PARTICLE_VELOCITY_CONTROL
        velocity = particle_simulation_data.velocity_factor * normalize(velocity);
        #endif

        // Integrate position.
        position = fma(velocity, dt, position);

        // Handle collisions.
        CollisionHandling(position, velocity);

        // Update the particle.
        UpdateParticle(p, position, velocity, age);

        // Save it in buffer.
        PushParticle(p);
    }
}
